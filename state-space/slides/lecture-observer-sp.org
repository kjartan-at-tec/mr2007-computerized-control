#+OPTIONS: toc:nil
# #+LaTeX_CLASS: koma-article 

#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=1610]
#+OPTIONS: H:2
# #+BEAMER_THEME: Madrid
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt)
     
#+LaTex_HEADER: \usepackage{khpreamble, euscript}
#+LaTex_HEADER: \DeclareMathOperator{\atantwo}{atan2}
#+LaTex_HEADER: \newcommand*{\ctrb}{\EuScript{C}}
#+LaTex_HEADER: \newcommand*{\obsv}{\EuScript{O}}

#+title: Control computarizado - Retroalimentación con observador

* What do I want the students to understand?			   :noexport:
  - Understand observer feedback

* Which activities will the students do?			   :noexport:

* Apollo moon lander
** Ejemplo - El módulo lunar de Apollo

   #+begin_export latex
   \begin{center}
   \includegraphics[width=\linewidth]{fig-apollo}
   \end{center}
   #+end_export

*** Notas                                                          :noexport:
    Ayer vímos este modelo del módulo lunar de Apollo. El modelo es para el control de la velocidad horizaontal, z dot. Cambié la dirección de esta flecha que representa el empuje del propulsor principal, para que enseña la fuerza que actua en el módulo. Para que este se mantenga a cierta distancia del superficie de la luna, esta fuerza tiene que tener un componente vertical con magnitúd mg, donde este g es la acceleration de gravedad en el superficie de la luna, que es 1.62 m/s^2.

    Cuando el módulo tiene un  angula al respeto al vertical, esta fuerza de propulso va a tener un componente horizontal. Cual es su magnitúd?

    La dinámica del sistema está expresado abajo en forma de un diagrama de bloques. La señal de entrada es el torque causada por los propulsores de atitúd. Esta causa una acceleracińo angular del módulo de 1/J por el torque, dónde J es el momento de inertia. Integrando la acceleración nos da la velocidad angular. 

    Si vemos las fuerzas en la dirección horizontal, vemos que 
    m\ddot{z} = F_h = mg tan\theta
    \ddot{z} = g \tan\theta \approz g \theta, entonces k2=g

    Integrando la acceleración nos da la velocidad.

    La approximación lineal tiene la función de transferencia G = k_1k_2/s^3 = (g/J) / s^3

    Es una sistema de orden tres, entonces se necesita tres variables de estado para representar su dinámica. 
** Ejemplo - El módulo lunar de Apollo
   Variables del estado: \( x = \begin{bmatrix} x_1 & x_2 & x_3 \end{bmatrix}^T = \begin{bmatrix} \dot{\theta} & \theta & \dot{z} \end{bmatrix}^T\). Con dinamica
   \[ \begin{cases} \dot{x}_1 =  \ddot{\theta} = k_1 u\\ \dot{x}_2 = \dot{\theta} = x_1\\ \dot{x}_3 = \ddot{z} = k_2\theta = k_2x_2 \end{cases} \]

   \[ \dot{x} = \begin{bmatrix} \dot{x}_1\\\dot{x}_2\\\dot{x}_3\end{bmatrix} = \underbrace{\begin{bmatrix} \textcolor{red!60!black}{0} & \textcolor{red!60!black}{0} &\textcolor{red!60!black}{0} \\\textcolor{red!60!black}{1} & \textcolor{red!60!black}{0}& \textcolor{red!60!black}{0}\\ \textcolor{red!60!black}{0}& \textcolor{red!60!black}{k_2} &\textcolor{red!60!black}{0} \end{bmatrix}}_{A} \begin{bmatrix} x_1\\x_2\\x_3\end{bmatrix} + \underbrace{\begin{bmatrix} \textcolor{red!60!black}{k_1} \\ \textcolor{red!60!black}{0} \\\textcolor{red!60!black}{0}  \end{bmatrix}}_{B} u \]


* Matlab demo
** Matlab / Simulink
* State feedback with observer
** Control por retroalimentación de estados reconstruidos
** Retroalimentación de estados
   Dado
   \begin{equation}
   \begin{split}
    x(k+1) &= \Phi x(k) + \Gamma u(k)\\
    y(k) &= C x(k)
   \end{split}
   \label{eq:ssmodel}
  \end{equation}
  y medidas (o valores estimados) del vector de estado \(x(k)\). 

  *Reltroalimentación lineal de estados* es la ley de control
  \begin{equation*}
  \begin{split}
   u(k) &= f\big((x(k), u_c(k)\big) = -l_1x_1(k) - l_2x_2(k) - \cdots - l_n x_n(k) + l_0u_c(k)\\
        &= -Lx(k) + l_0u_c(k), 
  \end{split}
  \end{equation*}
  dónde \[ L = \bbm l_1 & l_2 & \cdots & l_n \ebm. \]
  Sustitoyende la ley de control en el modelo en espacio de estado \eqref{eq:ssmodel} da 
   \begin{equation}
   \begin{split}
    x(k+1) &= \left(\Phi -\Gamma L \right) x(k) + m\Gamma u_c(k)\\
    y(k) &= C x(k)
   \end{split}
   \label{eq:closedloop}
  \end{equation}

** Control por retroalimentación de estados reconstruidos
** Asignación de polos por retroalimentación de estados
   Dado ubicación deseada de los polos del lazo cerrado \(p_1, p_2, \ldots, p_n\), correspondiente al polinomio característico deseado
   \begin{equation}
   a_c(z) = (z-p_1)(z-p_2)\cdots(z-p_n) = z^n + \alpha_1 z^{n-1} + \cdots \alpha_n.
   \label{eq:desiredpoles}
   \end{equation}

   Retroalimentación de estados nos da el sistema 
   \begin{equation}
   \begin{split}
    x(k+1) &= \left(\Phi -\Gamma L \right) x(k) + l_0\Gamma u_c(k)\\
    y(k) &= C x(k)
   \end{split}
   \label{eq:closedloop}
  \end{equation}
  con polinomio característico
   \begin{equation}
   \det\left(zI - (\Phi - \Gamma L)\right) = z^n + \beta_1(l_1,\ldots,l_n) z^{n-1} + \cdots \beta_n(l_1, \ldots, l_n).
   \label{eq:poles}
   \end{equation}
  
   Equipara los coeficientes de \eqref{eq:desiredpoles} con los de \eqref{eq:poles} para obtener sistema de ecuaciones
   \begin{equation*}
   \begin{split}
   \beta_1(l_1, \ldots, l_n) &= \alpha_1\\
   \beta_2(l_1, \ldots, l_n) &= \alpha_2\\
   &\vdots\\
   \beta_n(l_1, \ldots, l_n) &= \alpha_n
   \end{split}
   \label{eq:coeffs}
   \end{equation*}

** Asignación de polos por retroalimentación de estados
   El sistema de ecuaciones
   \begin{equation*}
   \begin{split}
   \beta_1(l_1, \ldots, l_n) &= \alpha_1\\
   \beta_2(l_1, \ldots, l_n) &= \alpha_2\\
   &\vdots\\
   \beta_n(l_1, \ldots, l_n) &= \alpha_n
   \end{split}
   \label{eq:coeffs}
   \end{equation*}
   siempre es lineal en los parámetros del controlador, cuál nos da
   \begin{equation*}
   M L\transp = \alpha,
   \end{equation*}
   dónde \(\alpha\transp = \bbm \alpha_1 & \alpha_2 & \cdots & \alpha_n \ebm.\)

** Asignación de polos y controlabilidad
   Se puede verificar que la matriz de controlabilidad 
   \[W_c = \bbm \Gamma & \Phi\Gamma & \cdots & \Phi^{n-1}\Gamma\ebm\]
   es un factór de la matriz \(M\)
   \[ M = \bar{M} W_c. \] Entonces, en general las ecuaciones
   \begin{equation}
   \bar{M}W_c L\transp = \alpha \qquad \Rightarrow \qquad L\transp = W_c^{-1}\bar{M}^{-1}\alpha
   \label{eq:poleplace}
   \end{equation}
   solo tienen una solución si \(W_c\) es invertible, es decir cuando el sistema es /controlable/.

   Nota que las ecuaciones \eqref{eq:poleplace} pueden tener soluciónes (numero infinito) cuando el sistema no es controlable, si  *\(\alpha\) está en el espacio de columnas de \(M\)*. Es decir, se puede escribir 
  \[ \alpha = b_1 M_{:,1} + b_2M_{:,2} + \cdots + b_M_{:,m}, \; m < n \]
 
** Asignación de polos por retroalimentación de estados
   Dado ubicación deseada de los polos del lazo cerrado \(p_1, p_2, \ldots, p_n\), correspondiente al polinomio característico deseado
   \begin{equation}
   a_c(z) = (z-p_1)(z-p_2)\cdots(z-p_n) = z^n + \alpha_1 z^{n-1} + \cdots \alpha_n.
   \end{equation}
   y sistema de espacio de estado en lazo cerrado
   \begin{equation}
   \begin{split}
    x(k+1) &= \left(\Phi -\Gamma L \right) x(k) + l_0\Gamma u_c(k)\\
    y(k) &= C x(k)
   \end{split}
  \end{equation}

  Matlab (/control systems toolbox/) tiene dos métodos para calcular las ganancias $L$

  1. *Método de Ackerman* 
     #+begin_src octave
	L = acker(Phi, Gamma, pd)
     #+end_src
  1. *Método numericamente estable* 
     #+begin_src octave
	L = place(Phi, Gamma, pd)
     #+end_src

** La ganancia \(l_0\) de la referencia

   El sistema de espacio de estado en lazo cerrado
   \begin{equation*}
   \begin{split}
    x(k+1) &= \underbrace{\left(\Phi -\Gamma L \right)}_{\Phi_c} x(k) + l_0\Gamma u_c(k)\\
    y(k) &= C x(k)
   \end{split}
   \end{equation*}
   tiene la solución en estado estacionario (\(x(k+1)=x(k)\)) con referencia constante \(u_c(k) = u_{c,f}\)
   \[ y_f = l_0 C(I - \Phi_c)^{-1}\Gamma u_{c,f}.\]
   Queremos \(y_f =  u_{c,f}\),
   \[ \Rightarrow \qquad l_0 = \frac{1}{C(I-\Phi_c)^{-1}\Gamma}\]

** Matlab   
** Actividad
   En grupos: 
   1. Visualiza la atitúd (angulo \(\theta\) en grados) del módulo lunar durante la simulación. Cuál es el angulo máximo?
   2. Determina las ganancias \(L = \bbm l_1 & l_2 & l_3 \ebm\) para control /dead-beat/. Es decir con todos los polos del sistema en lazo cerrado en el origen.
   3. Simula el sistema en lazo cerrado con control dead-beat. Cuál es el angulo máximo del módulo lunar?
   4. Cambia el periodo de muestreo de \(h=1\)s a \(h=0.5\)s. Cuál es el angulo máximo ahora, usando control  dead-beat.
